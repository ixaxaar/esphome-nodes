esphome:
  name: xiao-air-quality
  friendly_name: XIAO Air Quality Monitor

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  framework:
    type: arduino

# Enable logging
logger:
  level: DEBUG
  logs:
    i2c: DEBUG

# Enable Home Assistant API
api:

ota:
  - platform: esphome
    password: !secret web_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "XIAO-PM2.5 Hotspot"
    password: !secret ap_password

# Sync time with NTP
time:
  - platform: sntp
    id: sntp_time
    timezone: "Asia/Kolkata"

web_server:
  port: 80
  auth:
    username: admin
    password: !secret web_password

# I2C configuration for XIAO ESP32S3
i2c:
  sda: GPIO5 # PIN_D4 (SDA)
  scl: GPIO6 # PIN_D5 (SCL)
  scan: true
  frequency: 50kHz
  id: bus_a

# Template sensors for PM readings (placeholder until proper sensor driver available)
sensor:
  - platform: template
    name: "PM1.0"
    id: pm1_0
    unit_of_measurement: "µg/m³"
    icon: "mdi:air-filter"
    accuracy_decimals: 0
    device_class: pm1
    lambda: |-
      // Direct I2C communication with sensor
      uint8_t data[32];
      Wire.beginTransmission(0x19);
      Wire.write(0x11);  // Wake command
      Wire.write(0x02);  // Read command  
      Wire.endTransmission();
      delay(50);
      
      int bytes = Wire.requestFrom(0x19, 32);
      if (bytes > 0) {
        for(int i = 0; i < bytes && i < 32; i++) {
          data[i] = Wire.read();
        }
        
        // Try to find valid PM1.0 data
        for(int i = 0; i < bytes - 1; i++) {
          uint16_t val = (data[i] << 8) | data[i+1];
          if (val > 0 && val < 300) return val;  // PM1.0 usually lower than PM2.5
        }
      }
      return 0;
    update_interval: 30s

  - platform: template
    name: "PM2.5"
    id: pm2_5
    unit_of_measurement: "µg/m³"
    icon: "mdi:air-filter"
    accuracy_decimals: 0
    device_class: pm25
    lambda: |-
      // Direct I2C read for PM2.5
      uint8_t data[32];
      Wire.beginTransmission(0x19);
      Wire.write(0x11);
      Wire.write(0x02);
      Wire.endTransmission();
      delay(50);
      
      int bytes = Wire.requestFrom(0x19, 32);
      if (bytes > 0) {
        for(int i = 0; i < bytes && i < 32; i++) {
          data[i] = Wire.read();
        }
        
        // Look for PM2.5 data
        for(int i = 0; i < bytes - 1; i++) {
          uint16_t val = (data[i] << 8) | data[i+1];
          if (val > 0 && val < 500) return val;
        }
      }
      return 0;
    update_interval: 5s

  - platform: template
    name: "PM10"
    id: pm10
    unit_of_measurement: "µg/m³"
    icon: "mdi:air-filter"
    accuracy_decimals: 0
    device_class: pm10
    lambda: |-
      // Direct I2C read for PM10
      uint8_t data[32];
      Wire.beginTransmission(0x19);
      Wire.write(0x11);
      Wire.write(0x02);
      Wire.endTransmission();
      delay(50);
      
      int bytes = Wire.requestFrom(0x19, 32);
      if (bytes > 0) {
        for(int i = 0; i < bytes && i < 32; i++) {
          data[i] = Wire.read();
        }
        
        // Look for PM10 data (usually highest values)
        for(int i = 0; i < bytes - 1; i++) {
          uint16_t val = (data[i] << 8) | data[i+1];
          if (val > 0 && val < 1000) return val;
        }
      }
      return 0;
    update_interval: 30s

  # WiFi Signal Sensor
  - platform: wifi_signal
    name: "WiFi Signal Sensor"
    update_interval: 60s

  # Uptime sensor
  - platform: uptime
    name: "Uptime Sensor"

# Text sensors
text_sensor:
  - platform: version
    name: "ESPHome Version"
  - platform: wifi_info
    ip_address:
      name: "IP Address"
    ssid:
      name: "Connected SSID"
    mac_address:
      name: "MAC Address"

# Status LED
status_led:
  pin:
    number: GPIO21
    inverted: true